#include <iostream>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <algorithm>

#include <mutex>
#include <string>
#include <vector>
#include <map>

#include "rpc.h"
#include "mr_protocol.h"

using namespace std;

struct KeyVal {
    string key;
    string val;
};

//
// The map function is called once for each file of input. The first
// argument is the name of the input file, and the second is the
// file's complete contents. You should ignore the input file name,
// and look only at the contents argument. The return value is a slice
// of key/value pairs.
//
vector<KeyVal> Map(const string &filename, const string &content)
{
	// Copy your code from mr_sequential.cc here.
	stringstream s;
    vector<KeyVal> res;
    s<<content;
    string key;
    while (true)
    {
        s>>key;
        string finalkey;
         if (s.eof())
        {
            break;
        }
        for (int i=0;i<key.size();i++)
        {
            
            if (!((key[i]>='a'&&key[i]<='z')||(key[i]>='A'&&key[i]<='Z')))
            {
                continue;
            }
            string tmp;
            while (((key[i]>='a'&&key[i]<='z')||(key[i]>='A'&&key[i]<='Z'))&&i<key.size())
            {
                tmp+=key[i];
                i++;

            }
            KeyVal tmp2;
        tmp2.key=tmp;
        tmp2.val="1";
        res.push_back(tmp2);

           
            
        }
        

    }
    return res;

}

//
// The reduce function is called once for each key generated by the
// map tasks, with a list of all the values created for that key by
// any map task.
//
string Reduce(const string &key, const vector < string > &values)
{
    // Copy your code from mr_sequential.cc here.
	int res=0;
    for (int i=0;i<values.size();i++)
    {
        res+=atoi(values[i].c_str());
    }
    string rs=to_string(res);
    return rs;


}


typedef vector<KeyVal> (*MAPF)(const string &key, const string &value);
typedef string (*REDUCEF)(const string &key, const vector<string> &values);

class Worker {
public:
	Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf);

	void doWork();

private:
	void doMap(int index, const vector<string> &filenames);
	void doReduce(int index);
	void doSubmit(mr_tasktype taskType, int index);

	mutex mtx;
	int id;

	rpcc *cl;
	std::string basedir;
	MAPF mapf;
	REDUCEF reducef;
};


Worker::Worker(const string &dst, const string &dir, MAPF mf, REDUCEF rf)
{
	this->basedir = dir;
	this->mapf = mf;
	this->reducef = rf;

	sockaddr_in dstsock;
	make_sockaddr(dst.c_str(), &dstsock);
	this->cl = new rpcc(dstsock);
	if (this->cl->bind() < 0) {
		printf("mr worker: call bind error\n");
	}
}

void Worker::doMap(int index, const vector<string> &filenames)
{
	// Lab2: Your code goes here.
	string filename=filenames[0];
	string content;
	getline(ifstream(filename), content, '\0');
	vector <KeyVal> KVA = Map(filename, content);
	string outputname0="mr_"+to_string(index)+"_0"+".txt";
	ofstream output0;
	output0.open("./"+outputname0,ios::app);

	string outputname1="mr_"+to_string(index)+"_1"+".txt";
	ofstream output1;
	output1.open("./"+outputname1,ios::app);

	string outputname2="mr_"+to_string(index)+"_2"+".txt";
	ofstream output2;
	output2.open("./"+outputname2,ios::app);

	string outputname3="mr_"+to_string(index)+"_3"+".txt";
	ofstream output3;
	output3.open("./"+outputname3,ios::app);


	
	for (int i=0;i<KVA.size();i++)
	{
		string key=KVA[i].key;
		string val=KVA[i].val;
		int idx=(key[0]-'A')%4;
		switch(idx)
		{
			case 0:
		{output0.write(key.c_str(),key.size());
		string b;
		b[0]=' ';
		output0.write(b.c_str(),1);
		output0.write(val.c_str(),val.size());
		string a;
		a[0]='\n';
		output0.write(a.c_str(),1);
		break;
		}
		case 1:
		{
			output1.write(key.c_str(),key.size());
		string b;
		b[0]=' ';
		output1.write(b.c_str(),1);
		output1.write(val.c_str(),val.size());
		string a;
		a[0]='\n';
		output1.write(a.c_str(),1);
		break;
		}
		case 2:
		{
			output2.write(key.c_str(),key.size());
		string b;
		b[0]=' ';
		output2.write(b.c_str(),1);
		output2.write(val.c_str(),val.size());
		string a;
		a[0]='\n';
		output2.write(a.c_str(),1);
		break;

		}
		case 3:
		{
			output3.write(key.c_str(),key.size());
		string b;
		b[0]=' ';
		output3.write(b.c_str(),1);
		output3.write(val.c_str(),val.size());
		string a;
		a[0]='\n';
		output3.write(a.c_str(),1);
		break;
		}
		}
	}
	output0.close();
	output1.close();
	output2.close();
	output3.close();
}

void Worker::doReduce(int index)
{
	// Lab2: Your code goes here.
	
	
		vector <KeyVal> intermediate;
		for (int i=0;i<6;i++)
		{
			
				ifstream is;
				string fn="mr_"+to_string(i)+"_"+to_string(index)+".txt";
				is.open("./"+fn,ios::in);
				string content;
				getline(is, content, '\0');
				stringstream ss;
				ss<<content;
				while (true)
				{
					string key;
					string val;
					ss>>key;
					if (ss.eof()) break;
					ss>>val;
					KeyVal tmp;
					tmp.key=key;
					tmp.val=val;
					intermediate.push_back(tmp);
				}
				is.close();

			
		}
		sort(intermediate.begin(), intermediate.end(),
    	[](KeyVal const & a, KeyVal const & b) {
		return a.key < b.key;
	});
	ofstream of;
	
	of.open("./mr-out-"+to_string(index)+".txt",ios::app);
	
	   for (unsigned int i = 0; i < intermediate.size();) {
        unsigned int j = i + 1;
        for (; j < intermediate.size() && intermediate[j].key == intermediate[i].key;)
            j++;

        vector < string > values;
        for (unsigned int k = i; k < j; k++) {
            values.push_back(intermediate[k].val);
        }

        string output = Reduce(intermediate[i].key, values);
        printf("%s %s\n", intermediate[i].key.data(), output.data());
		of.write(intermediate[i].key.c_str(),intermediate[i].key.size());
		string space;
		space[0]=' ';
		of.write(space.c_str(),1);
		of.write(output.c_str(),output.size());
		string newline;
		newline[0]='\n';
		of.write(newline.c_str(),1);

        i = j;
    }
	of.close();


	
	

}

void Worker::doSubmit(mr_tasktype taskType, int index)
{
	bool b;
	mr_protocol::status ret = this->cl->call(mr_protocol::submittask, taskType, index, b);
	if (ret != mr_protocol::OK) {
		fprintf(stderr, "submit task failed\n");
		exit(-1);
	}
}

void Worker::doWork()
{
	for (;;) {

		//
		// Lab2: Your code goes here.
		// Hints: send asktask RPC call to coordinator
		// if mr_tasktype::MAP, then doMap and doSubmit
		// if mr_tasktype::REDUCE, then doReduce and doSubmit
		// if mr_tasktype::NONE, meaning currently no work is needed, then sleep
		//
		
		int r;
		mr_protocol::AskTaskResponse res;
		this->cl->call(mr_protocol::asktask,r,res);
		switch (res.tasktype)
		{
			case mr_tasktype::MAP:
			{
				vector<string> tmp;
				tmp.push_back(res.filenames);
				doMap(res.index,tmp);
				doSubmit(mr_tasktype::MAP,res.index);
				break;

			}

			case mr_tasktype::REDUCE:
			{
				doReduce(res.index);
				doSubmit(mr_tasktype::REDUCE,res.index);
				break;
			}

			case mr_tasktype::NONE:
			{
				sleep(1);
				break;
			}
		}

	}
}

int main(int argc, char **argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: %s <coordinator_listen_port> <intermediate_file_dir> \n", argv[0]);
		exit(1);
	}

	MAPF mf = Map;
	REDUCEF rf = Reduce;
	
	Worker w(argv[1], argv[2], mf, rf);
	w.doWork();

	return 0;
}

